\documentclass[hidelinks,a4paper,12pt, nofootinbib]{article}
\usepackage[width=15.5cm, left=3cm, top=2.5cm, right=2cm, left=2cm, height= 24.5cm]{geometry}
\usepackage[spanish, es-tabla]{babel} %es-tabla es para que ponga Tabla en vez de Cuadro en el caption
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{caratula}
\usepackage[bottom]{footmisc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{array}
\usepackage{xcolor,colortbl}
\usepackage{amsthm}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{sidecap}
\usepackage{wrapfig}
\usepackage{caption}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = blue, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor   = red %Colour of citations
}

%%fancyhdr
\pagestyle{fancy}
\thispagestyle{fancy}
\addtolength{\headheight}{1pt}
\lhead{Sistemas Operativos: TP2}
\rhead{$1º$ cuatrimestre de 2016}
\cfoot{\thepage\ / \pageref{LastPage}}
\renewcommand{\footrulewidth}{0.4pt}
\renewcommand{\labelitemi}{$\bullet$}

\definecolor{LightCyan}{rgb}{0.77,0.9,0.9}

% Datos de caratula
\materia{Sistemas Operativos}
\titulo{Trabajo Práctico 2}
\subtitulo{Pthreads}
\grupo{}

\integrante{Costa, Manuel José Joaquin}{035/14}{manucos94@gmail.com}
\integrante{Coy, Camila Paula}{033/14}{camicoy94@gmail.com}
\integrante{Ginsberg, Mario Ezequiel}{145/14}{ezequielginsberg@gmail.com}

\fecha{8 de Junio de 2016}

\begin{document}
\maketitle
\tableofcontents
\newpage

\subsection{Read-Write Lock}
Para implementar el \texttt{RWLock} utilizamos los siguientes atributos privados:
\begin{itemize}
	\item \texttt{mutex}
	\item \texttt{cv\_write}: Una variable de condición para la variable \texttt{write}. 
	\item \texttt{cv\_read}: Una variable de condición para la variable \texttt{cant\_reads}.
	\item \texttt{cant\_reads}: Tiene la cantidad de lecturas que se estan realizando.
	\item \texttt{write}: Un booleano que cuando llega un write se pone en true. Lo usamos para evitar que los threads que realizan reads le generen inanición a los threads que quieren hacer write.
\end{itemize}

Además usamos los siguientes métodos públicos:
\begin{itemize}
	\item \texttt{RWLock()}: Inicializa el mutex, las variables de condición, \texttt{cant\_reads} y \texttt{write}.
	\item \texttt{void rlock()}: Genera el lock para los reads. Si llega un write deja esperando los reads para que no pueda haber inanición, luego aumenta \texttt{cant\_reads}, ya que hay alguien leyendo. 
	\item \texttt{void runlock()}: Decrementa \texttt{cant\_reads} indicando que dejo de leer. Si después de eso \texttt{cant\_reads} = 0 entonces envía un broadcast a todos los threads que están esperando por la variable de condición \texttt{cv\_write}.
	\item \texttt{void wlock()}: Genera el lock para los writes. Si llegan reads o writes, quedan bloqueados hasta que se haga el  \texttt{void wlock()}. Notar que lockea el \texttt{mutex} y no lo libera.
	\item \texttt{void wunlock()}: 
\end{itemize}
\subsection{Servidor}
Para el servidor nos basamos en \texttt{backend-mono}, haciendole los cambios necesarios para que pudo soportar más de un jugador. 
Cada vez que acepta a un jugador crea un thread para atenderlo mediante la función \texttt{atenderdor\_de\_jugador} y guardamos la información del thread en un vector. Además creamos dos vectores de vectores de RWLock para proteger ambos tableros y todos los lugares donde en \texttt{backend-mono} se escribío o leyo algun tablero agregamos las protecciones de este.
Para poder saber cuando todos los jugadores mandaron el mensaje de LISTO y poder pasar a la fase de batalla, creamos la variable \texttt{cant\_clientes} y la protegimos para que no la puedan modificar dos threads a la vez. Entonces cada vez que entra un cliente entra aumentamos en uno esta variable, y cada vez que un thread muere o un jugador dice LISTO esta decrementa.


\end{document}
